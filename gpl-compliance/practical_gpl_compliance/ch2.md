CHAPTER 2:

第二章：

# Common Pitfalls
# 常见的陷阱

## "We demand rigidly defined areas of doubt and uncertainty!"
## “我们要求严格界定怀疑和不确定性的领域！”

DOUGLAS ADAMS

道格拉斯亚当斯

## Pitfall #1: Toolchain
## 陷阱#1：工具链

One component that is essential for doing a rebuild is the toolchain, which consists of the compiler, assembler/linker/et cetera, and a C library. For embedded Linux systems, the compiler is almost always GCC (although LLVM is starting to be used), the assembler/ linker comes from GNU binutils, and the C library is glibc or uClibc (both LGPL licensed) or musl (MIT licensed) on "regular" embedded Linux, and bionic on Android systems (although glibc is frequently used on Android too for add on programs). Although LLVM and musl are being used increasingly in embedded systems, they are still the exception.

进行重建必不可少的一个组件是工具链，它由编译器、汇编器/链接器等以及一个C库组成。对于嵌入式Linux系统，编译器几乎都是采用GCC（尽管现在开始使用了LLVM），汇编器/链接器来自GNU binutils，在“常规”嵌入式Linux上，C库一般采用glibc或uClibc（这两者都获得了LGPL许可）或是musl（MIT 许可），在安卓系统上一般采用bionic（虽然在安卓系统上，glibc也经常用于附加程序）。尽管LLVM和musl在嵌入式系统中的使用越来越多，但它们仍然是例外。

The toolchain is often found to be not compliant. A common scenario is that a toolchain with GCC and GNU binutils is provided in binary-only form, without the source code or the offer for the source code. Although it is possible to use the provided binary toolchain to rebuild the binaries, it is not the correct approach. The GCC compiler and GNU binutils are released under GPL v2 or v3, depending on the version. Their source code, or a written offer for the source code, should be included with the binary. When glibc or uClibc is used, there is an additional reason: Parts of the (prebuilt) toolchain (from the C library) are sometimes copied from the toolchain into a firmware image. This means that the sources and configuration to rebuild the C library need to be provided too (as per the LGPL license conditions). The quickest way to fulfill the requirements is by having the complete toolchain sources.

工具链经常被检测发现不合规。通常的情况是，带有GCC和GNU binutils的工具链仅以二进制形式提供，没有源代码或源代码的提供者信息。虽然可以使用提供的二进制工具链来重建二进制文件，但这不是正确的使用方法。GCC编译器和GNU binutils通常是基于GPL v2或GPL v3发布的，具体取决于版本信息。他们的源代码或源代码的提供者信息文件应包含在二进制文件中。当使用glibc或 uClibc时，还有一个额外的要求：有时需要将部分的（预编译）工具链（大部分来自C库）从工具链复制到固件镜像中。这意味着（根据LGPL的许可条件）还需要提供重构C库的源代码和配置信息。满足需求的最快方法是拥有完整的工具链资源。

Another consideration is that for embedded Linux, the toolchain is a necessary component in rebuilding the binary. Embedded Linux devices use different CPUs than regular PCs. While regular PCs use Intel or AMD chips based on the x86 or x86-64 architectures, the embedded devices are often built using ARM, MIPS, or PowerPC chips (although other architectures can be found too). The binaries for these platforms are generated by a so-called "cross-compiler" that runs on a regular PC but outputs code for a different platform such as MIPS or ARM. Building a working cross-compiler is a non-trivial task; without the sources and the exact description how to rebuild the cross-compiler (either using a script or the manual instructions), it will be very difficult to recreate the correct setup to perform a rebuild.

另一个考虑因素是，对于嵌入式Linux系统，工具链是重构二进制文件的必要组件。嵌入式Linux设备的CPU与普通PC不同。普通PC使用的是基于x86或x86-64架构的Intel或AMD芯片，而嵌入式设备通常使用ARM、MIPS或PowerPC芯片（也可以发现有其他芯片架构）构建而成。这些平台的二进制文件由号称的“交叉编译器”生成，该编译器在普通的PC上运行，但输出用于不同平台（如MIPS或ARM）的代码。构建一个可运行的交叉编译器是一项非常重要的任务；如果没有源代码和如何重构交叉编译器的确切描述（包括使用的脚本或是手动安装说明），将很难配置正确，重构成功。

## Pitfall #2: Android and Embedded Devices

Systems that are either running Android or that borrow heavily from
Android, may have a few common pitfalls.

#### Android prebuilt tools

The standard Android software development kit as shipped by Google
comes with a large number of tools that are prebuilt for various
platforms, such as Linux, Darwin, and Microsoft Windows, and even
Linux kernel images for QEMU. Many of these tools are licensed under
GPL or LGPL, such as GCC and binutils, cmake, gdb, and many others.
These files can easily be identified by looking for directories that
contain "prebuilt":

\$ find -d /path/to/android/sdk \| grep prebuilt

These directories often contain a variety of prebuilt tools or even
Linux kernel images that may be without obviously placed corresponding
source code or written offer. Frequently there is a file called
"PREBUILT" in the directory that also contains the binaries. This file
points to source code and sometimes also contains more detailed build
instructions. As an example (from an earlier version of Android, for
the ccache tool):

The objects in this prebuilt directory can be rebuilt using the source
archive

ccache-2.4-android-20070905.tar.gz hosted at
[\<http://android.kernel.org/pub/\.](http://android.kernel.org/pub/)

It should be noted that these particular instructions may not be good
enough to result in GPL compliance for chipset manufacturers, ODMs,
and their downstream recipients, for a number of reasons:

1.  This method does not produce a valid written offer, according to
    GPLv2 section 3b. While they arguably cover the originator of the
    code by the "equivalent access" clause in GPLv2 section 3 (because
    they distribute the source code only online), the instructions do
    not extend to the chipset manufacturers, the ODMs, and their
    downstream recipients.

2.  As of the publication date of this book, it should be noted that one
    commonly referred to location for Android source, called
    android.kernel.org, has been offline since September 2011. This
    means that the relevant source code can no longer be found at this
    particular location, though it may be found at other URLs.

Having these prebuilt components in the source code archive without
the corresponding source code can present a compliance risk.

One solution is to also include the source code for these prebuilt
components. Another solution is to remove the components if they are
not needed to do a rebuild (e.g., in most cases, it makes sense to
remove the binaries for MS Windows and Darwin), or to replace the
prebuilt components, if they are actually needed for the build, with
instructions on how to fetch the prebuilt components from Android's
Git server. You should make sure that the exact same version as the
prebuilt versions is fetched; otherwise the build might fail or it
might be difficult to compare binaries (see "Performing a Rebuild").
It should be noted that for some components, such as the toolchain, it
might

still be necessary to provide sources, in case glibc or uClibc has
been used and shipped on the device or in the firmware.

#### Missing/Incorrect License Files

Android's build system generates a NOTICES.html.gz file that is
displayed by default in the "legal" tab on a phone or tablet. This
file is generated by a script that looks for files that indicate the
license status, called "NOTICE."

For some tools and programs in Android, you may find missing license
identifiers or have used the wrong license text (in case of the Linux
kernel). These omissions were fixed in the most recent versions of
Android (Android 6, possibly later versions of 5), but many older
versions (including several versions of Android 5) do not have these
fixes. Chipset manufacturers and ODMs typically have not applied the
existing fixes because they were not informed by Google. The omission
of these texts has been raised in enforcement cases.

The most common omissions and errors are with:

-   iproute2 --- missing license reference in the NOTICES file

-   iptables --- missing license reference in the NOTICES file

-   Linux kernel --- sometimes wrong version of the license in the
    NOTICES file (Linux kernel 2.6-specific)

Fixing these issues is not hard at all, and patches are readily
available, as described below.

###### *iptables*

The notices and license files for iptables are missing in older
versions of Android. Google fixed the bug in the following Git commit:

**[https://android.googlesource.com/platform/external/](https://android.googlesource.com/platform/external/iptables/%2B/b6da12d1a9020e2819f3c449244801a285659f)
[iptables/+/b6da12d1a9020e2819f3c449244801a285659f81](https://android.googlesource.com/platform/external/iptables/%2B/b6da12d1a9020e2819f3c449244801a285659f)**

###### *iproute2*

The notices and license files for iproute2 are missing in older
versions of Android. Google fixed the bug in the following Git commit:
**[https://android.googlesource.com/platform/external/](https://android.googlesource.com/platform/external/iproute2/%2B/5aa4845c8ef3ea0371955a2ba5f7baf7ed4e2d)
[iproute2/+/5aa4845c8ef3ea0371955a2ba5f7baf7ed4e2df4](https://android.googlesource.com/platform/external/iproute2/%2B/5aa4845c8ef3ea0371955a2ba5f7baf7ed4e2d)**

###### *Linux kernel*

The Linux kernel license file is sometimes wrong, because Google used
the license text of a prebuilt Linux kernel (2.6.x), which has a
slightly different license text than later versions. This was not a
problem for Android versions using the 2.6.x kernel, but when the
Linux kernel moved to 3.x and later 4.x, the license text was not
entirely correct. Google fixed this in late 2015:

**[https://android.googlesource.com/platform/build/+/](https://android.googlesource.com/platform/build/%2B/b463fcde80f5615b3fe6891b8b78c010ec8cd37b)
[b463fcde80f5615b3fe6891b8b78c010ec8cd37b](https://android.googlesource.com/platform/build/%2B/b463fcde80f5615b3fe6891b8b78c010ec8cd37b)**

## Pitfall #3: "Out of tree" Linux Kernel Modules

Many vendors ship Linux kernel modules that add functionality that is
not provided by the standard Linux kernel, or that is not yet present
in the version shipped for the device, such as support for certain
hardware, firewalling modules, new security features, etc. Linux
kernel modules for the 2.6 and later releases have the ".ko"
extension. Kernel modules for the 2.4 and older kernel often have the
extension ".o" (but that could also be used for regular object files).

For these so-called "out of tree" kernel modules, it is important to
find out which license they are under and if there is complete and
corresponding source code.

Linux kernel modules can contain several fields that detail things
such as the author and a description, but also a license field. An

example from Linux kernel 4.5. (file "drivers/clk/clk-pwm.c") looks
like this:

MODULE_AUTHOR("Philipp Zabel

[\<p.zabel@pengutronix.de\");](mailto:p.zabel@pengutronix.de)
MODULE_DESCRIPTION("PWM clock driver"); MODULE_LICENSE("GPL");

These fields are then included in the kernel module binary when

it is built. They can later be extracted from the binary either by
using the "modinfo" tool (preferred) or manually (as recent versions
of "modinfo" no longer support the format for Linux kernel 2.4 or
older). The important fields to look at are the author field and the
license field. The author field usually indicates the copyright
holders of the specific code being reviewed. The license field could
indicate the possible license of a file. This field is quite
important, as certain pieces of functionality in the Linux kernel can
only be used by modules that have explicitly declared that they are
GPL-licensed.

It also happens that kernel modules are distributed in a firmware or
source code archive, but they are not used, because they are never
loaded by the operating system, either because there are no programs
to load them, or because the operating system does not allow it (it
may be a different version or even a completely different
architecture). Finding out if a module is used is outside of the scope
of this book.

#### Extracting License and Author Fields from a Kernel Module

The license field can be extracted from a Linux kernel module using
the modinfo tool:

\$ modinfo -l /path/to/kernel/module

Similarly, the author field can be extracted using:

\$ modinfo -a /path/to/kernel/module

Note: Recent versions of the modinfo program no longer have support
for kernel modules for Linux kernel 2.4.X and earlier (using the ".o"
extension). For those modules, you can use the "strings" command
instead:

\$ strings /path/to/kernel/module \| grep -i license

#### Extracting Version and Architecture Fields from a Kernel Module

Similarly to the license field, the version and architecture
information can easily be retrieved from a Linux kernel module:

\$ modinfo /path/to/kernel/module \| grep \^vermagic

For 2.4.X and earlier, the version can be extracted as follows
(because the modinfo tool on recent Linux distributions no longer can
process modules for 2.4 or earlier):

\$ strings /path/to/kernel/module \| grep kernel\_ version

The architecture can be retrieved using different means, such as the
"file" command:

\$ file /path/to/kernel/module

## Pitfall #4: Rescue Mode/Install Mode Systems

Quite a few embedded Linux devices have a special mode that is used
only for system recovery (rescue mode) or when installing a new
firmware. This is done by booting a different Linux kernel from a
different partition on the flash memory. These rescue partitions are
often not updated when a new firmware is released and are simply
forgotten. However, for compliance, it is very important to have the
complete and corresponding source code for all of the different Linux
systems that are used on a device or while updating a firmware.

These rescue partitions tend to have different contents than other
partitions. It is very common to see that both the rescue partition
and the normal one have a copy of BusyBox, but with a different size
and set of tools integrated. This means that they were built with
different configurations. It is also not uncommon to see that a
different Linux kernel (older version, known to work) has been used,
but that the source code releases have the source code only for the
Linux kernel that is booted in normal operation. There have also been
instances where the C library was different (uClibc in the rescue
partition, glibc in the normal partition, and so on).

It also happens that a separate version of Linux is booted only to
perform the installation of a new firmware, and that version is
embedded in the firmware update itself and is not on the device. Or,
it could be that there are three different instances of Linux involved
in one single firmware update: a temporary Linux booted when
performing the update, a different version when writing a rescue
partition, as well as a third version for the regular partition. It is
important to look at everything that is installed or used at
installation time: The device and the firmware update are both
important.

## Pitfall #5: Bootloader

One overlooked component in compliance engineering is the bootloader.
A few commonly used bootloaders on embedded Linux systems (e.g.,
U-Boot and Redboot) are GPL-licensed. The reason they are overlooked
is because they come preflashed on the boards or chips, and ODMs
frequently do not touch this component at all. Many times the
bootloader is also not included in a firmware update, but the firmware
update overwrites only parts of the flash chip in a device and leaves
the bootloader alone. However, if the bootloader is GPL- licensed,
source code for the bootloader should be delivered as well.

If possible, perform your analysis on the firmware update as shipped
to customers (see "Pitfall #4") as well as on a dump of the flash
contents of the actual device, unless the firmware update is actually
the same as the flash dump.

If the bootloader is not included, it might be necessary to extract
the contents of the bootloader from the device. This is outside of the
scope of this book.

## Pitfall #6: Missing Build System

There are build systems that separate the sources of packages and the
description of how to build them. Some build systems have a directory
called "download" or "dl" that contains the sources, while the
Makefiles, configurations, and patches are in a separate directory.
Some companies will publish the contents of the directory only with
the sources but not the build system.

This is wrong for a few reasons:

1.  Any patches that might have been applied are now not included,
    meaning that the source code is incomplete.

2.  []{#_bookmark14 .anchor}Makefiles and other build scripts often
    contain configuration options (environment variables, compiler
    options, etc.) that influence how a package is built. Without this
    information, the binary cannot be rebuilt successfully, or at least
    not (near-)identically.

## Pitfall #7: Incorrect or Missing BusyBox Configuration Files

An often-encountered problem is that BusyBox cannot be rebuilt in such
a way that it corresponds to the binary or binaries in a firmware. The
BusyBox program is very modular; functionality can be added or removed
by editing a configuration file (usually using a special configuration
program). This configuration file is read during build time and
determines which functionalities (called "applets") will be included
in the BusyBox binary. The configuration file is therefore a very
necessary part of the "complete and corresponding source code," and a
missing or incorrect configuration file for BusyBox has been enforced
many times.

#### Missing BusyBox configuration file

Source code release archives often contain only the source code for
BusyBox, but not the configuration, because the build system is not
included (see Pitfall #6).

An easy check for this is to look for a file called ".config" in the
top-level source code file of the BusyBox source code tree. If it
cannot be found, it might be in a separate directory in the build
system, if present.

#### Incorrect BusyBox configuration file

Another problem encountered at times is that the BusyBox

[]{#_bookmark15 .anchor}configuration file or files are incorrect: The
original binary and the rebuilt binary have different sets of applets.
In many of these cases, the chipset manufacturer or ODM cannot find or
recreate the correct configuration file.

It is possible (with tools contained in the Binary Analysis Tool) to
re-create a BusyBox configuration file that could be used as the basis
of re-creating the real configuration file. However, this solution
should be used only as a last resort.

#### Multiple different BusyBox binaries, one configuration file

Quite often there are multiple BusyBox binaries included in a
firmware, each with a different configuration. A common example is a
rescue system (see Pitfall #4) that contains a minimal version of
BusyBox, with the full system containing a BusyBox instance with much
more functionality. The source code archive should include the
configurations for all Busybox instances that are in use on the
device, but frequently, the configuration for only one of the
instances of BusyBox is present.

## Pitfall #8: Incorrect or Missing Linux Kernel Configuration Files

Very similarly to Pitfall #7, the configuration file for the Linux
kernel is often missing or incorrect.

#### Finding which Linux kernel configuration was used

Finding out what configuration was used to build a Linux kernel binary
is not always trivial, and sometimes a rebuild and comparison (as
described earlier in this book) will be necessary. Sometimes the
kernel configuration will be included in the Linux kernel binary

as a bzip2 compressed file. This happens if the "CONFIG\_ IKCONFIG"
option was enabled during the kernel build. In that case, it is easy
to find the kernel configuration that was actually used (for example,
by unpacking the binary with the Binary Analysis Tool and then looking
for the configuration). If the configuration was not stored in the
Linux kernel image, then your only option to verify whether a kernel
configuration is 100% correct is a rebuild and compare.

#### Missing Linux kernel configuration file

Source code release archives often contain only the source code for
the Linux kernel, but not the configuration. Depending on the setup,
the Linux kernel configuration could be in various locations. One
common location is a file ".config" in the root of the Linux kernel
source tree (generated by the Linux kernel configuration commands like
"make config" or "make menuconfig"). Another location is in the "arch"
subdirectory. By default, the Linux kernel source code tree contains
many configuration files, and vendors tend to put the configurations
there. For example, "arch/arm/ configs/bcm2835_defconfig" contains the
configuration for a particular Broadcom board. Which configuration
file to use is set by the build scripts. A third option is that the
configuration file is kept outside of the Linux kernel archive, with
the build scripts, and is first copied to the Linux kernel source code
tree during the build. If the build system is missing (see Pitfall #6)
and the configuration file is not included in the Linux kernel
archive, then the Linux kernel source code will not be complete and
corresponding.

#### Multiple Linux kernel binaries, one configuration file

Quite often there are multiple Linux kernel binaries included in a
firmware, each with a different configuration. A common example is a
rescue system (see Pitfall #4) which contains a minimal version of the
Linux kernel, with the full system containing a Linux kernel

[]{#_bookmark16 .anchor}instance with much more functionality. The
source code archive, however, may have the configuration for only one
of the two versions (or three, or even more).

#### Incorrect Linux kernel configuration file

It also happens that the Linux kernel configuration file may simply be
not correct and that the appropriate Linux kernel binary cannot be
compiled because functionality has been added or removed in the
configuration.

## Pitfall #9: Not Including the Version Number in Firmware and Source Code Archive Filenames

One very common mistake is that firmwares and corresponding source
code archives often do not have the version name (and the device name)
in the filename, but use a generic name, such as "GPL.zip," for
various devices and versions of source code. This makes it very easy
to make mistakes and deliver the wrong files, which might lead to the
impression that you are out of compliance.

The solution is to use, or demand that suppliers use, a naming
convention that would include:

-   Device name/model number (or multiple, if the files are identical)

-   Firmware revision number

-   Revision level

For example: A device called AB-123 with firmware 1.2.3.4 would have a
firmware filename "FW_AB-123_1.2.3.4.bin" and a source code archive
filename "GPL_AB-123_1.2.3.4-0.bin."

Using naming conventions like these will make it a lot easier to
locate the right files, avoid making mistakes, and spot errors on
download sites.

