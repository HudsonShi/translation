CHAPTER 2:

第二章：

# Common Pitfalls
# 常见的陷阱

## "We demand rigidly defined areas of doubt and uncertainty!"
## “我们需要严格界定怀疑和不确定性的领域！”

DOUGLAS ADAMS

道格拉斯亚当斯

## Pitfall #1: Toolchain
## 陷阱#1：工具链

One component that is essential for doing a rebuild is the toolchain, which consists of the compiler, assembler/linker/et cetera, and a C library. For embedded Linux systems, the compiler is almost always GCC (although LLVM is starting to be used), the assembler/ linker comes from GNU binutils, and the C library is glibc or uClibc (both LGPL licensed) or musl (MIT licensed) on "regular" embedded Linux, and bionic on Android systems (although glibc is frequently used on Android too for add on programs). Although LLVM and musl are being used increasingly in embedded systems, they are still the exception.

进行重建必不可少的一个组件是工具链，它由编译器、汇编器/链接器等以及一个C库组成。对于嵌入式Linux系统，编译器几乎都是采用GCC（尽管现在开始使用了LLVM），汇编器/链接器来自GNU binutils，在“常规”嵌入式Linux上，C库一般采用glibc或uClibc（这两者都获得了LGPL许可）或是musl（MIT 许可），在Android系统上一般采用bionic（虽然在Android系统上，glibc也经常用于附加程序）。尽管LLVM和musl在嵌入式系统中的使用越来越多，但它们仍然是例外。

The toolchain is often found to be not compliant. A common scenario is that a toolchain with GCC and GNU binutils is provided in binary-only form, without the source code or the offer for the source code. Although it is possible to use the provided binary toolchain to rebuild the binaries, it is not the correct approach. The GCC compiler and GNU binutils are released under GPL v2 or v3, depending on the version. Their source code, or a written offer for the source code, should be included with the binary. When glibc or uClibc is used, there is an additional reason: Parts of the (prebuilt) toolchain (from the C library) are sometimes copied from the toolchain into a firmware image. This means that the sources and configuration to rebuild the C library need to be provided too (as per the LGPL license conditions). The quickest way to fulfill the requirements is by having the complete toolchain sources.

工具链经常被检测发现不合规。通常的情况是，带有GCC和GNU binutils的工具链仅以二进制形式提供，没有源代码或源代码的书面要约。虽然可以使用提供的二进制工具链来重建二进制文件，但这不是正确的使用方法。GCC编译器和GNU binutils通常是基于GPL v2或GPL v3发布的，具体取决于版本信息。他们的源代码或源代码的提供者信息文件应包含在二进制文件中。当使用glibc或 uClibc时，还有一个额外的要求：有时需要将部分的（预编译）工具链（大部分来自C库）从工具链复制到固件镜像中。这意味着（根据LGPL的许可条件）还需要提供重构C库的源代码和配置信息。满足需求的最快方法是拥有完整的工具链资源。

Another consideration is that for embedded Linux, the toolchain is a necessary component in rebuilding the binary. Embedded Linux devices use different CPUs than regular PCs. While regular PCs use Intel or AMD chips based on the x86 or x86-64 architectures, the embedded devices are often built using ARM, MIPS, or PowerPC chips (although other architectures can be found too). The binaries for these platforms are generated by a so-called "cross-compiler" that runs on a regular PC but outputs code for a different platform such as MIPS or ARM. Building a working cross-compiler is a non-trivial task; without the sources and the exact description how to rebuild the cross-compiler (either using a script or the manual instructions), it will be very difficult to recreate the correct setup to perform a rebuild.

另一个考虑因素是，对于嵌入式Linux系统，工具链是重构二进制文件的必要组件。嵌入式Linux设备的CPU与普通PC不同。普通PC使用的是基于x86或x86-64架构的Intel或AMD芯片，而嵌入式设备通常使用ARM、MIPS或PowerPC芯片（也可以发现有其他芯片架构）构建而成。这些平台的二进制文件由号称的“交叉编译器”生成，该编译器在普通的PC上运行，但输出用于不同平台（如MIPS或ARM）的代码。构建一个可运行的交叉编译器是一项非常重要的任务；如果没有源代码和如何重构交叉编译器的确切描述（包括使用的脚本或是手动安装说明），将很难配置正确，重构成功。

## Pitfall #2: Android and Embedded Devices
## 陷阱#2： Android和嵌入式设备

Systems that are either running Android or that borrow heavily from Android, may have a few common pitfalls.

运行Android系统或与Android类似的系统可能会遇到一些常见的缺陷。

#### Android prebuilt tools
#### Android预构建工具包

The standard Android software development kit as shipped by Google comes with a large number of tools that are prebuilt for various platforms, such as Linux, Darwin, and Microsoft Windows, and even Linux kernel images for QEMU. Many of these tools are licensed under GPL or LGPL, such as GCC and binutils, cmake, gdb, and many others. These files can easily be identified by looking for directories that contain "prebuilt":

谷歌发布的标准Android软件开发工具包，附带了大量为各种平台预编译的工具，例如Linux、Darwin和Microsoft Windows，甚至还有用于QEMU的Linux内核镜像。这些工具中有许多是GPL或LGPL许可的，例如GCC和binutils、cmake、gdb等。通过查找包含“prebuilt”的目录，可以轻松找到这些文件：

\$ find -d /path/to/android/sdk \| grep prebuilt

These directories often contain a variety of prebuilt tools or even Linux kernel images that may be without obviously placed corresponding source code or written offer. Frequently there is a file called "PREBUILT" in the directory that also contains the binaries. This file points to source code and sometimes also contains more detailed build instructions. As an example (from an earlier version of Android, for the ccache tool):

这些目录通常包含各种预编译的工具，甚至是Linux内核镜像，在它们里面可能没有放置相应的源代码或源代码的书面要约。在目录中通常有一个名为“PREBUILT”的文件也包含二进制文件。该文件指向源代码，有时还包含更详细的构建说明。作为示例（来自早期的Android版本，用于ccache工具）：

The objects in this prebuilt directory can be rebuilt using the source archive ccache-2.4-android-20070905.tar.gz hosted at [\<http://android.kernel.org/pub/\>.](http://android.kernel.org/pub/)

可以使用托管在[\<http://android.kernel.org/pub/\>](http://android.kernel.org/pub/)的源文件归档文件ccache-2.4-android-20070905.tar.gz 重构此预编译目录中的文件内容。

It should be noted that these particular instructions may not be good enough to result in GPL compliance for chipset manufacturers, ODMs, and their downstream recipients, for a number of reasons:

需要注意的是，这些特定的指令可能不足以使芯片组制造商、ODM及其下游接收者遵守GPL协议，原因有很多：

1.  This method does not produce a valid written offer, according to GPLv2 section 3b. While they arguably cover the originator of the code by the "equivalent access" clause in GPLv2 section 3 (because they distribute the source code only online), the instructions do not extend to the chipset manufacturers, the ODMs, and their downstream recipients.

   根据GPLv2协议第3b节，此方法不会产生有效的书面要约。虽然他们可以通过GPLv2第3节中的“等效访问”条款来涵盖代码的发起者（因为他们仅在线分发源代码），但这些说明并未扩展到芯片组制造商、ODM及其下游接收者。

2.  As of the publication date of this book, it should be noted that one commonly referred to location for Android source, called android.kernel.org, has been offline since September 2011. This means that the relevant source code can no longer be found at this particular location, though it may be found at other URLs.

    自2011年9月以来，一个被称为Android源代码的网址：android.kernel.org，一直处于离线状态，需要注意的是截至本书出版之日时仍然如此。这意味着在这个网址已经无法找到相关的源代码，虽然它依然可能在其他网址中找到。

Having these prebuilt components in the source code archive without the corresponding source code can present a compliance risk.

在没有相应源代码的归档文件中找到的这些预构建组件，可能会给项目带来合规性风险。

One solution is to also include the source code for these prebuilt components. Another solution is to remove the components if they are not needed to do a rebuild (e.g., in most cases, it makes sense to remove the binaries for MS Windows and Darwin), or to replace the prebuilt components, if they are actually needed for the build, with instructions on how to fetch the prebuilt components from Android's Git server. You should make sure that the exact same version as the prebuilt versions is fetched; otherwise the build might fail or it might be difficult to compare binaries (see "Performing a Rebuild"). It should be noted that for some components, such as the toolchain, it might still be necessary to provide sources, in case glibc or uClibc has been used and shipped on the device or in the firmware.

一种解决方案是找到这些预构建组件的源代码，并将它们包含进去。另一种解决方案是，如果重建时不需要的组件，可以删除掉（例如，在大多数情况下，删除MS Windows和Darwin的二进制文件是可行的）；如果重新构建确实需要这些组件，可以替换预构建的组件，并提供如何从Android的Git服务器获取预构建组件的说明。需要确保服务器上获取的版本与预构建版本完全相同；否则构建可能会失败或者比较二进制文件可能会有问题（请参阅“执行重建”）。应该注意的是，对于某些组件（例如工具链），可能仍然需要提供源代码，以防止设备或固件中使用了glibc或uClibc。

#### Missing/Incorrect License Files
#### 缺少的/不正确的许可文件

Android's build system generates a NOTICES.html.gz file that is displayed by default in the "legal" tab on a phone or tablet. This file is generated by a script that looks for files that indicate the license status, called "NOTICE."

Android的构建系统会生成一个NOTICES.html.gz文件，在手机或平板电脑上，默认情况下该文件包含在“合法”选项卡中。该文件是由一个脚本生成，该脚本会查找指示许可证状态的相关文件，称为“NOTICE”。

For some tools and programs in Android, you may find missing license identifiers or have used the wrong license text (in case of the Linux kernel). These omissions were fixed in the most recent versions of Android (Android 6, possibly later versions of 5), but many older versions (including several versions of Android 5) do not have these fixes. Chipset manufacturers and ODMs typically have not applied the existing fixes because they were not informed by Google. The omission of these texts has been raised in enforcement cases.

对于Android中的一些工具和程序，您可能会发现缺少许可证标识符或使用了错误的许可文件（以Linux内核为例）。在最新版本的Android（Android6，可能是5之后的更高版本）中，这些遗漏已经得到修复，但许多旧版本（包括Android 5的多个版本）都还没有修复。芯片组制造商和ODM通常没有使用现有的修复程序，因为Google没有通知他们。在执行案件中，这些文本的遗漏已经被提出了。

The most common omissions and errors are with:

最常见的遗漏和错误是：

-   iproute2 --- missing license reference in the NOTICES file
-   iproute2 --- 在NOTICES文件中缺少许可证的引用

-   iptables --- missing license reference in the NOTICES file
-   iptables --- 在NOTICES文件中缺少许可证的引用

-   Linux kernel --- sometimes wrong version of the license in the NOTICES file (Linux kernel 2.6-specific)
-   Linux内核 --- 在NOTICES文件中有时会出现许可证版本错误（尤其是Linux内核2.6）

Fixing these issues is not hard at all, and patches are readily available, as described below.

修复这些问题一点都不难，修补程序也很容易获得，如下所述。

###### *iptables*

The notices and license files for iptables are missing in older versions of Android. Google fixed the bug in the following Git commit:

旧版本的Android系统中缺少iptables的通知和许可文件。Google修复了以下Git提交中的错误：

**[https://android.googlesource.com/platform/external/](https://android.googlesource.com/platform/external/iptables/%2B/b6da12d1a9020e2819f3c449244801a285659f)
[iptables/+/b6da12d1a9020e2819f3c449244801a285659f81](https://android.googlesource.com/platform/external/iptables/%2B/b6da12d1a9020e2819f3c449244801a285659f)**

###### *iproute2*

The notices and license files for iproute2 are missing in older versions of Android. Google fixed the bug in the following Git commit:

旧版本的Android系统中缺少iproute2的通知和许可文件。Google修复了以下Git提交中的错误：

**[https://android.googlesource.com/platform/external/](https://android.googlesource.com/platform/external/iproute2/%2B/5aa4845c8ef3ea0371955a2ba5f7baf7ed4e2d)
[iproute2/+/5aa4845c8ef3ea0371955a2ba5f7baf7ed4e2df4](https://android.googlesource.com/platform/external/iproute2/%2B/5aa4845c8ef3ea0371955a2ba5f7baf7ed4e2d)**

###### *Linux kernel*

The Linux kernel license file is sometimes wrong, because Google used the license text of a prebuilt Linux kernel (2.6.x), which has a slightly different license text than later versions. This was not a problem for Android versions using the 2.6.x kernel, but when the Linux kernel moved to 3.x and later 4.x, the license text was not
entirely correct. Google fixed this in late 2015:

Linux内核许可文件有时是错误的，因为Google使用了预构建Linux内核(2.6.x)的许可文本，其许可文本与更高版本的许可文件略有不同。这对于使用2.6.x内核的Android版本来说不是问题，但是当Linux内核迁移到3.x和更高的4.x版本时，许可文本并不完全正确。谷歌在2015年底修复了这个问题：

**[https://android.googlesource.com/platform/build/+/](https://android.googlesource.com/platform/build/%2B/b463fcde80f5615b3fe6891b8b78c010ec8cd37b)
[b463fcde80f5615b3fe6891b8b78c010ec8cd37b](https://android.googlesource.com/platform/build/%2B/b463fcde80f5615b3fe6891b8b78c010ec8cd37b)**

## Pitfall #3: "Out of tree" Linux Kernel Modules
## 陷阱#3：“外部的”Linux内核模块

Many vendors ship Linux kernel modules that add functionality that is not provided by the standard Linux kernel, or that is not yet present in the version shipped for the device, such as support for certain hardware, firewalling modules, new security features, etc. Linux kernel modules for the 2.6 and later releases have the ".ko"
extension. Kernel modules for the 2.4 and older kernel often have the extension ".o" (but that could also be used for regular object files).

许多供应商发布的Linux内核模块添加了标准的Linux内核未提供的功能，或者设备所提供的版本中尚不存在的功能，例如对某些硬件的支持、防火墙模块、新的安全功能等。Linux2.6及更高版本的内核模块通常具有“.ko”扩展名。2.4和更早版本的内核模块通常具有“.o”扩展名（但也可用于常规目标文件）。

For these so-called "out of tree" kernel modules, it is important to find out which license they are under and if there is complete and corresponding source code.

对于这些所谓的“外部的”内核模块，重要的是要弄清楚它们使用的哪个许可证，以及是否有完整的对应源代码。

Linux kernel modules can contain several fields that detail things such as the author and a description, but also a license field. An example from Linux kernel 4.5. (file "drivers/clk/clk-pwm.c") looks like this:

Linux内核模块可以包含多个详细的信息字段，比如作者和文件描述等，还有一个许可证字段。以Linux内核4.5为例，其（文件“drivers/clk/clk-pwm.c”）格式如下：

MODULE_AUTHOR("Philipp Zabel

[\<p.zabel@pengutronix.de\");](mailto:p.zabel@pengutronix.de)

MODULE_DESCRIPTION("PWM clock driver"); 

MODULE_LICENSE("GPL");

These fields are then included in the kernel module binary when it is built. They can later be extracted from the binary either by using the "modinfo" tool (preferred) or manually (as recent versions of "modinfo" no longer support the format for Linux kernel 2.4 or older). The important fields to look at are the author field and the
license field. The author field usually indicates the copyright holders of the specific code being reviewed. The license field could indicate the possible license of a file. This field is quite important, as certain pieces of functionality in the Linux kernel can only be used by modules that have explicitly declared that they are
GPL-licensed.

在构建内核模块二进制文件时，这些信息将包含在其中。之后可以使用“modinfo”工具（首选）或手动从二进制文件中提取它们（因为“modinfo”的最新版本不再支持Linux内核2.4或更高级的版本）。主要查看作者字段和许可证字段。作者字段通常表示审查当前代码的版权所有者。许可证字段可以指示文件的可能许可证。这个字段非常重要，因为Linux内核中的某些功能只能由明确声明为GPL许可的模块使用。

It also happens that kernel modules are distributed in a firmware or source code archive, but they are not used, because they are never loaded by the operating system, either because there are no programs to load them, or because the operating system does not allow it (it may be a different version or even a completely different
architecture). Finding out if a module is used is outside of the scope of this book.

还有一种情况是，内核模块分布在固件或源代码归档文件中，但未被使用过，因为操作系统从未加载过它们，要么是因为没有程序需要加载它们，要么是因为操作系统不允许（它可能是不同的版本，甚至是完全不同的体系结构）。确定一个模块是否被使用已经超出了本书的范围。

#### Extracting License and Author Fields from a Kernel Module
#### 从内核模块中提取许可证及作者信息

The license field can be extracted from a Linux kernel module using the modinfo tool:

使用以下的modinfo工具，可以从Linux内核模块中提取许可证字段：

\$ modinfo -l /path/to/kernel/module

Similarly, the author field can be extracted using:

类似地，可以通过以下方式提取作者字段：

\$ modinfo -a /path/to/kernel/module

Note: Recent versions of the modinfo program no longer have support for kernel modules for Linux kernel 2.4.X and earlier (using the ".o" extension). For those modules, you can use the "strings" command instead:

注意：最新版本的modinfo程序不再支持Linux内核2.4.X及更早版本的内核模块（使用“.o”扩展名）。对于这些模块，可以改用“strings”命令：

\$ strings /path/to/kernel/module \| grep -i license

#### Extracting Version and Architecture Fields from a Kernel Module
#### 从内核模块中提取版本及体系结构信息

Similarly to the license field, the version and architecture information can easily be retrieved from a Linux kernel module:

与许可证字段类似，可以从Linux内核模块轻松地提取版本和体系结构信息：

\$ modinfo /path/to/kernel/module \| grep \^vermagic

For 2.4.X and earlier, the version can be extracted as follows (because the modinfo tool on recent Linux distributions no longer can process modules for 2.4 or earlier):

对于2.4.X及更早的版本，可以按如下的方式提取版本信息（因为最近Linux发行版上的modinfo工具不再能够处理2.4或更早版本的模块）：

\$ strings /path/to/kernel/module \| grep kernel\_ version

The architecture can be retrieved using different means, such as the "file" command:

体系结构信息可以用不同的方法提取出来，比如“file”命令：

\$ file /path/to/kernel/module

## Pitfall #4: Rescue Mode/Install Mode Systems
## 陷阱#4：修复模式/安装系统模式

Quite a few embedded Linux devices have a special mode that is used only for system recovery (rescue mode) or when installing a new firmware. This is done by booting a different Linux kernel from a different partition on the flash memory. These rescue partitions are often not updated when a new firmware is released and are simply
forgotten. However, for compliance, it is very important to have the complete and corresponding source code for all of the different Linux systems that are used on a device or while updating a firmware.

很多的嵌入式Linux设备有一种特殊模式，仅用于系统恢复（修复模式）或安装新固件时使用。这是通过从闪存上的不同分区启动不同的Linux内核来完成的。当发布新固件时，这些救援分区通常被遗忘了，不会被更新。然而为了合规性，在设备上安装不同的Linux系统，或更新固件的系统时，为这些系统提供完整且相应的源代码是非常重要的。

These rescue partitions tend to have different contents than other partitions. It is very common to see that both the rescue partition and the normal one have a copy of BusyBox, but with a different size and set of tools integrated. This means that they were built with different configurations. It is also not uncommon to see that a
different Linux kernel (older version, known to work) has been used, but that the source code releases have the source code only for the Linux kernel that is booted in normal operation. There have also been instances where the C library was different (uClibc in the rescue partition, glibc in the normal partition, and so on).

这些救援分区的内容与其他分区往往不同。通常救援分区和普通分区都有一个BusyBox的副本，但具有不同的文件大小，并集成了不同的工具集。这意味着它们是用不同的配置构建的。通常它们也使用了不同的Linux内核（旧版本，已知有效），但只有正常启动下的Linux内核版本才包含源代码文件。也有一些C库不同的例子（如恢复分区中的uClibc，普通分区中的glibc等）。

It also happens that a separate version of Linux is booted only to perform the installation of a new firmware, and that version is embedded in the firmware update itself and is not on the device. Or, it could be that there are three different instances of Linux involved in one single firmware update: a temporary Linux booted when performing the update, a different version when writing a rescue partition, as well as a third version for the regular partition. It is important to look at everything that is installed or used at installation time: The device and the firmware update are both important.

另一种情况是，启动一个独立的Linux版本仅用于新固件的安装，而该版本嵌入在固件更新本身，不在设备上。还有一种情况，一次固件更新可能涉及三个不同的Linux实例：执行更新时启动一个临时的Linux，写入救援分区时使用一个不同的实例，以及常规分区使用的第三个实例。重要的是在安装时，要查看安装或使用的所有内容，包括设备和固件更新，它们都很重要。

## Pitfall #5: Bootloader
## 陷阱#5：引导分区

One overlooked component in compliance engineering is the bootloader. A few commonly used bootloaders on embedded Linux systems (e.g., U-Boot and Redboot) are GPL-licensed. The reason they are overlooked is because they come preflashed on the boards or chips, and ODMs frequently do not touch this component at all. Many times the
bootloader is also not included in a firmware update, but the firmware update overwrites only parts of the flash chip in a device and leaves the bootloader alone. However, if the bootloader is GPL- licensed, source code for the bootloader should be delivered as well.

合规工程中一个容易被忽视的组件是引导分区。嵌入式Linux系统上常用的引导分区（例如U-Boot和Redboot）是GPL许可的。被忽视的原因是因为它们被预先加载到了电路板或芯片上，而ODM通常无需接触这个组件。很多时候引导分区不包含在固件更新中，并且固件更新也只会覆盖设备中闪存芯片的一部分，不会影响到引导分区。但是如果引导分区是GPL许可的，则需要提供引导分区的源代码。

If possible, perform your analysis on the firmware update as shipped to customers (see "Pitfall #4") as well as on a dump of the flash contents of the actual device, unless the firmware update is actually the same as the flash dump.

如果可能，请对交付给客户的固件更新（请参阅“陷阱#4”）以及设备上的闪存的导出内容进行分析，确认固件更新与闪存的导出内容相同。

If the bootloader is not included, it might be necessary to extract the contents of the bootloader from the device. This is outside of the scope of this book.

如果不包含引导分区，则可能需要从设备中提取引导分区的内容。这超出了本书的范围。

## Pitfall #6: Missing Build System
## 缺陷#6：缺少构建系统

There are build systems that separate the sources of packages and the description of how to build them. Some build systems have a directory called "download" or "dl" that contains the sources, while the Makefiles, configurations, and patches are in a separate directory. Some companies will publish the contents of the directory only with the sources but not the build system.

有一些构建系统将源文件包和对源文件的构建描述分开。而有一些构建系统设置一个名为“download”或“dl”的目录，其中包含源代码，而将Makefile、配置和补丁文件位于单独的目录中。一些公司只发布目录的内容，而不发布构建系统。

This is wrong for a few reasons:

这是错误的，原因如下：

1.  Any patches that might have been applied are now not included, meaning that the source code is incomplete.

    现在的系统不包括后期可能应用的任何补丁，这意味着源代码不完整。

2.  Makefiles and other build scripts often contain configuration options (environment variables, compiler options, etc.) that influence how a package is built. Without this information, the binary cannot be rebuilt successfully, or at least not (near-)identically.

    Makefile文件和其他构建脚本通常包含各种配置选项（如环境变量、编译器选项等），这些配置信息说明了如何构建二进制包。如果没有这些信息，无法成功重构二进制文件，即使重构成功可能也不完全相同。    

## Pitfall #7: Incorrect or Missing BusyBox Configuration Files
## 缺陷#7：错误的或缺失的BusyBox配置文件

An often-encountered problem is that BusyBox cannot be rebuilt in such a way that it corresponds to the binary or binaries in a firmware. The BusyBox program is very modular; functionality can be added or removed by editing a configuration file (usually using a special configuration program). This configuration file is read during build time and determines which functionalities (called "applets") will be included in the BusyBox binary. The configuration file is therefore a very necessary part of the "complete and corresponding source code," and a missing or incorrect configuration file for BusyBox has been enforced many times.

经常遇到一个的问题是，不能以固件中对应的一个或多个二进制文件来重建BusyBox。BusyBox程序是非常模块化的；可以通过编辑配置文件（通常是使用特殊的配置程序）来添加或删除它的某项功能。在构建过程中读取配置文件信息，以确定哪些功能（也称为“小程序”）将包含在BusyBox二进制文件中。因此，配置文件是实现“完整且对应的源代码”的合规要求非常必要的一个部分，BusyBox的配置文件缺失或不正确的情况已经出现过多次。

#### Missing BusyBox configuration file
#### 缺失的BusyBox配置文件

Source code release archives often contain only the source code for BusyBox, but not the configuration, because the build system is not included (see Pitfall #6).

由于源代码发行版归档文件通常不包括构建系统（参见陷阱 #6），因此它只包含了BusyBox的源代码，而不包含配置文件，。

An easy check for this is to look for a file called ".config" in the top-level source code file of the BusyBox source code tree. If it cannot be found, it might be in a separate directory in the build system, if present.

可以简单地校验下，即在BusyBox源代码树的顶级源代码文件中，是否能查到名为“.config”的文件。如果找不到，它可能就被包含在构建系统的单独目录中（如果存在单独目录）。

#### Incorrect BusyBox configuration file
#### 错误的BusyBox配置文件

Another problem encountered at times is that the BusyBox configuration file or files are incorrect: The original binary and the rebuilt binary have different sets of applets. In many of these cases, the chipset manufacturer or ODM cannot find or recreate the correct configuration file.

有时遇到的另一个问题是BusyBox的配置文件不正确：原始的二进制文件和重建的二进制文件对应不同的小程序集。在许多情况下，芯片组制造商或ODM无法找到或重新构建正确的配置文件。

It is possible (with tools contained in the Binary Analysis Tool) to re-create a BusyBox configuration file that could be used as the basis of re-creating the real configuration file. However, this solution should be used only as a last resort.

可以（使用二进制分析工具中包含的工具）重新创建一个BusyBox配置文件，可以用该配置文件作为重新创建的基础。但是此解决方案只能作为最后的手段使用。

#### Multiple different BusyBox binaries, one configuration file
#### 多个不同的BusyBox二进制文件，但只有一个配置文件

Quite often there are multiple BusyBox binaries included in a firmware, each with a different configuration. A common example is a rescue system (see Pitfall #4) that contains a minimal version of BusyBox, with the full system containing a BusyBox instance with much more functionality. The source code archive should include the
configurations for all Busybox instances that are in use on the device, but frequently, the configuration for only one of the instances of BusyBox is present.

一个固件中通常包含多个BusyBox二进制文件，每个二进制文件都有不同的配置。一个常见的例子是恢复系统（参见陷阱#4），它包含BusyBox的最小版本，而完整系统则包含一个具有多个功能的BusyBox实例。源代码归档文件应该覆盖设备上所包含的多个Busybox实例的配置信息，但通常只含有一个BusyBox实例的配置文件。

## Pitfall #8: Incorrect or Missing Linux Kernel Configuration Files
## 陷阱#8：错误的或缺失的Linux内核配置文件

Very similarly to Pitfall #7, the configuration file for the Linux kernel is often missing or incorrect.

类似于陷阱#7，Linux内核的配置文件经常丢失或是不正确。

#### Finding which Linux kernel configuration was used
#### 查找使用了哪个Linux内核配置

Finding out what configuration was used to build a Linux kernel binary is not always trivial, and sometimes a rebuild and comparison (as described earlier in this book) will be necessary. Sometimes the kernel configuration will be included in the Linux kernel binary as a bzip2 compressed file. This happens if the "CONFIG\_ IKCONFIG" option was enabled during the kernel build. In that case, it is easy to find the kernel configuration that was actually used (for example, by unpacking the binary with the Binary Analysis Tool and then looking for the configuration). If the configuration was not stored in the Linux kernel image, then your only option to verify whether a kernel configuration is 100% correct is a rebuild and compare.

找出用于构建Linux内核二进制文件的配置不那么简单，有时候需要进行重构，并进行对比（如本书前面所述）。有时候内核配置文件会被压缩为bzip2格式，包含在Linux内核二进制文件中。如果在构建内核的过程中启用了“CONFIG\_ IKCONFIG”选项，就会发生这种情况。在这种情况下很容易找到实际使用的内核配置文件（例如，通过二进制分析工具解压缩二进制文件，然后查找）。如果配置文件没有包含在Linux内核镜像中，那么验证内核配置是否100%正确的唯一方法就是重构并比对。

#### Missing Linux kernel configuration file
#### 缺失的Linux内核配置文件

Source code release archives often contain only the source code for the Linux kernel, but not the configuration. Depending on the setup, the Linux kernel configuration could be in various locations. One common location is a file ".config" in the root of the Linux kernel source tree (generated by the Linux kernel configuration commands like "make config" or "make menuconfig"). Another location is in the "arch" subdirectory. By default, the Linux kernel source code tree contains
many configuration files, and vendors tend to put the configurations there. For example, "arch/arm/ configs/bcm2835_defconfig" contains the configuration for a particular Broadcom board. Which configuration file to use is set by the build scripts. A third option is that the configuration file is kept outside of the Linux kernel archive, with the build scripts, and is first copied to the Linux kernel source code tree during the build. If the build system is missing (see Pitfall #6)
and the configuration file is not included in the Linux kernel archive, then the Linux kernel source code will not be complete and corresponding.

源代码发行版归档文件通常只包含Linux内核的源代码，而不包含配置文件。根据设置的不同，Linux内核配置文件可能位于不同的位置。通常是位于Linux内核源代码的根目录中的“.config”文件（由“make config”或“make menuconfig”等Linux内核配置命令生成）。还有是位于“arch”子目录中。默认情况下，Linux内核源代码树包含多个配置文件，厂商倾向于将配置文件放在那里。例如，“arch/arm/configs/bcm2835_defconfig”包含特定的Broadcom主板的配置。使用哪个配置文件由构建脚本设置。第三种情况是将配置文件与构建脚本一起保存在Linux内核归档文件之外，并在构建过程之前先复制到Linux内核源代码树中。如果缺少构建系统（请参阅陷阱#6），并且配置文件也未包含在Linux内核归档文件中，则Linux内核源代码将不完整且不对应。

#### Multiple Linux kernel binaries, one configuration file
#### 多个Linux内核二进制文件，一个配置文件

Quite often there are multiple Linux kernel binaries included in a firmware, each with a different configuration. A common example is a rescue system (see Pitfall #4) which contains a minimal version of the Linux kernel, with the full system containing a Linux kernel instance with much more functionality. The source code archive, however, may have the configuration for only one of the two versions (or three, or even more).

一个固件中经常包含多个Linux内核二进制文件，每个都有不同的配置。一个常见的例子是恢复系统（参见陷阱#4），它包含一个Linux内核的最小版本，而完整的系统包含一个具有多个功能的 Linux内核实例。然而，源代码归档文件可能只有两个版本（或三个，甚至更多）中的一种配置。

#### Incorrect Linux kernel configuration file
#### 错误的Linux内核配置文件

It also happens that the Linux kernel configuration file may simply be not correct and that the appropriate Linux kernel binary cannot be compiled because functionality has been added or removed in the configuration.

Linux内核配置文件可能根本不正确，并且由于在配置文件中添加或删除了某些功能，因此无法编译适当的Linux内核二进制文件。

## Pitfall #9: Not Including the Version Number in Firmware and Source Code Archive Filenames
## 陷阱#9：不包括固件和源代码归档文件名中的版本号

One very common mistake is that firmwares and corresponding source code archives often do not have the version name (and the device name) in the filename, but use a generic name, such as "GPL.zip," for various devices and versions of source code. This makes it very easy to make mistakes and deliver the wrong files, which might lead to the impression that you are out of compliance.

一个常见的错误是固件和相应的源代码归档文件的文件名中没有包含版本信息（和设备名称），而是使用通用名称，例如“GPL.zip” ，用于各种设备和源代码版本。这就很容易犯错误并提交错误的文件，可能会给人留下不合规的印象。

The solution is to use, or demand that suppliers use, a naming convention that would include:

解决方案是使用或要求供应商使用命名约定，该约定包括：

-   Device name/model number (or multiple, if the files are identical)

    包含设备名称/型号（如果文件相同则包含多个）

-   Firmware revision number

    固件修订版本号

-   Revision level

    修订级别

For example: A device called AB-123 with firmware 1.2.3.4 would have a firmware filename "FW_AB-123_1.2.3.4.bin" and a source code archive filename "GPL_AB-123_1.2.3.4-0.bin."

例如：名为AB-123、固件为1.2.3.4的设备的固件文件名为“FW_AB-123_1.2.3.4.bin”，源代码归档文件名为“GPL_AB-123_1.2.3.4-0.bin”。

Using naming conventions like these will make it a lot easier to locate the right files, avoid making mistakes, and spot errors on download sites.

按照这样的命名约定，可以更容易地查找正确的文件，避免出错，并很容易在下载站点上发现错误。

