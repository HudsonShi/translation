CHAPTER 2:

第二章：

# Common Pitfalls
# 常见的陷阱

## "We demand rigidly defined areas of doubt and uncertainty!"
## “我们需要严格界定怀疑和不确定性的领域！”

DOUGLAS ADAMS

道格拉斯亚当斯

## Pitfall #1: Toolchain
## 陷阱#1：工具链

One component that is essential for doing a rebuild is the toolchain, which consists of the compiler, assembler/linker/et cetera, and a C library. For embedded Linux systems, the compiler is almost always GCC (although LLVM is starting to be used), the assembler/ linker comes from GNU binutils, and the C library is glibc or uClibc (both LGPL licensed) or musl (MIT licensed) on "regular" embedded Linux, and bionic on Android systems (although glibc is frequently used on Android too for add on programs). Although LLVM and musl are being used increasingly in embedded systems, they are still the exception.

进行重建必不可少的一个组件是工具链，它由编译器、汇编器/链接器等以及一个C库组成。对于嵌入式Linux系统，编译器几乎都是采用GCC（尽管现在开始使用了LLVM），汇编器/链接器来自GNU binutils，在“常规”嵌入式Linux上，C库一般采用glibc或uClibc（这两者都获得了LGPL许可）或是musl（MIT 许可），在Android系统上一般采用bionic（虽然在Android系统上，glibc也经常用于附加程序）。尽管LLVM和musl在嵌入式系统中的使用越来越多，但它们仍然是例外。

The toolchain is often found to be not compliant. A common scenario is that a toolchain with GCC and GNU binutils is provided in binary-only form, without the source code or the offer for the source code. Although it is possible to use the provided binary toolchain to rebuild the binaries, it is not the correct approach. The GCC compiler and GNU binutils are released under GPL v2 or v3, depending on the version. Their source code, or a written offer for the source code, should be included with the binary. When glibc or uClibc is used, there is an additional reason: Parts of the (prebuilt) toolchain (from the C library) are sometimes copied from the toolchain into a firmware image. This means that the sources and configuration to rebuild the C library need to be provided too (as per the LGPL license conditions). The quickest way to fulfill the requirements is by having the complete toolchain sources.

工具链经常被检测发现不合规。通常的情况是，带有GCC和GNU binutils的工具链仅以二进制形式提供，没有源代码或源代码的书面要约。虽然可以使用提供的二进制工具链来重建二进制文件，但这不是正确的使用方法。GCC编译器和GNU binutils通常是基于GPL v2或GPL v3发布的，具体取决于版本信息。他们的源代码或源代码的提供者信息文件应包含在二进制文件中。当使用glibc或 uClibc时，还有一个额外的要求：有时需要将部分的（预编译）工具链（大部分来自C库）从工具链复制到固件镜像中。这意味着（根据LGPL的许可条件）还需要提供重构C库的源代码和配置信息。满足需求的最快方法是拥有完整的工具链资源。

Another consideration is that for embedded Linux, the toolchain is a necessary component in rebuilding the binary. Embedded Linux devices use different CPUs than regular PCs. While regular PCs use Intel or AMD chips based on the x86 or x86-64 architectures, the embedded devices are often built using ARM, MIPS, or PowerPC chips (although other architectures can be found too). The binaries for these platforms are generated by a so-called "cross-compiler" that runs on a regular PC but outputs code for a different platform such as MIPS or ARM. Building a working cross-compiler is a non-trivial task; without the sources and the exact description how to rebuild the cross-compiler (either using a script or the manual instructions), it will be very difficult to recreate the correct setup to perform a rebuild.

另一个考虑因素是，对于嵌入式Linux系统，工具链是重构二进制文件的必要组件。嵌入式Linux设备的CPU与普通PC不同。普通PC使用的是基于x86或x86-64架构的Intel或AMD芯片，而嵌入式设备通常使用ARM、MIPS或PowerPC芯片（也可以发现有其他芯片架构）构建而成。这些平台的二进制文件由号称的“交叉编译器”生成，该编译器在普通的PC上运行，但输出用于不同平台（如MIPS或ARM）的代码。构建一个可运行的交叉编译器是一项非常重要的任务；如果没有源代码和如何重构交叉编译器的确切描述（包括使用的脚本或是手动安装说明），将很难配置正确，重构成功。

## Pitfall #2: Android and Embedded Devices
## 陷阱#2： Android和嵌入式设备

Systems that are either running Android or that borrow heavily from Android, may have a few common pitfalls.

运行Android系统或与Android类似的系统可能会遇到一些常见的缺陷。

#### Android prebuilt tools
#### Android预构建工具包

The standard Android software development kit as shipped by Google comes with a large number of tools that are prebuilt for various platforms, such as Linux, Darwin, and Microsoft Windows, and even Linux kernel images for QEMU. Many of these tools are licensed under GPL or LGPL, such as GCC and binutils, cmake, gdb, and many others. These files can easily be identified by looking for directories that contain "prebuilt":

谷歌发布的标准Android软件开发工具包，附带了大量为各种平台预编译的工具，例如Linux、Darwin和Microsoft Windows，甚至还有用于QEMU的Linux内核镜像。这些工具中有许多是GPL或LGPL许可的，例如GCC和binutils、cmake、gdb等。通过查找包含“prebuilt”的目录，可以轻松找到这些文件：

\$ find -d /path/to/android/sdk \| grep prebuilt

These directories often contain a variety of prebuilt tools or even Linux kernel images that may be without obviously placed corresponding source code or written offer. Frequently there is a file called "PREBUILT" in the directory that also contains the binaries. This file points to source code and sometimes also contains more detailed build instructions. As an example (from an earlier version of Android, for the ccache tool):

这些目录通常包含各种预编译的工具，甚至是Linux内核镜像，在它们里面可能没有放置相应的源代码或源代码的书面要约。在目录中通常有一个名为“PREBUILT”的文件也包含二进制文件。该文件指向源代码，有时还包含更详细的构建说明。作为示例（来自早期的Android版本，用于ccache工具）：

The objects in this prebuilt directory can be rebuilt using the source archive ccache-2.4-android-20070905.tar.gz hosted at [\<http://android.kernel.org/pub/\>.](http://android.kernel.org/pub/)

可以使用托管在[\<http://android.kernel.org/pub/\>](http://android.kernel.org/pub/)的源存档文件ccache-2.4-android-20070905.tar.gz 重构此预编译目录中的文件内容。

It should be noted that these particular instructions may not be good enough to result in GPL compliance for chipset manufacturers, ODMs, and their downstream recipients, for a number of reasons:

需要注意的是，这些特定的指令可能不足以使芯片组制造商、ODM及其下游接收者遵守GPL协议，原因有很多：

1.  This method does not produce a valid written offer, according to GPLv2 section 3b. While they arguably cover the originator of the code by the "equivalent access" clause in GPLv2 section 3 (because they distribute the source code only online), the instructions do not extend to the chipset manufacturers, the ODMs, and their downstream recipients.

   根据GPLv2协议第3b节，此方法不会产生有效的书面要约。虽然他们可以通过GPLv2第3节中的“等效访问”条款来涵盖代码的发起者（因为他们仅在线分发源代码），但这些说明并未扩展到芯片组制造商、ODM及其下游接收者。

2.  As of the publication date of this book, it should be noted that one commonly referred to location for Android source, called android.kernel.org, has been offline since September 2011. This means that the relevant source code can no longer be found at this particular location, though it may be found at other URLs.

    自2011年9月以来，一个被称为Android源代码的网址：android.kernel.org，一直处于离线状态，需要注意的是截至本书出版之日时仍然如此。这意味着在这个网址已经无法找到相关的源代码，虽然它依然可能在其他网址中找到。

Having these prebuilt components in the source code archive without the corresponding source code can present a compliance risk.

在没有相应源代码的代码存档中找到的这些预构建组件，可能会给项目带来合规性风险。

One solution is to also include the source code for these prebuilt components. Another solution is to remove the components if they are not needed to do a rebuild (e.g., in most cases, it makes sense to remove the binaries for MS Windows and Darwin), or to replace the prebuilt components, if they are actually needed for the build, with instructions on how to fetch the prebuilt components from Android's Git server. You should make sure that the exact same version as the prebuilt versions is fetched; otherwise the build might fail or it might be difficult to compare binaries (see "Performing a Rebuild"). It should be noted that for some components, such as the toolchain, it might still be necessary to provide sources, in case glibc or uClibc has been used and shipped on the device or in the firmware.

一种解决方案是找到这些预构建组件的源代码，并将它们包含进去。另一种解决方案是，如果重建时不需要的组件，可以删除掉（例如，在大多数情况下，删除MS Windows和Darwin的二进制文件是可行的）；如果重新构建确实需要这些组件，可以替换预构建的组件，并提供如何从Android的Git服务器获取预构建组件的说明。需要确保服务器上获取的版本与预构建版本完全相同；否则构建可能会失败或者比较二进制文件可能会有问题（请参阅“执行重建”）。应该注意的是，对于某些组件（例如工具链），可能仍然需要提供源代码，以防止设备或固件中使用了glibc或uClibc。

#### Missing/Incorrect License Files
#### 缺少的/不正确的许可文件

Android's build system generates a NOTICES.html.gz file that is displayed by default in the "legal" tab on a phone or tablet. This file is generated by a script that looks for files that indicate the license status, called "NOTICE."

Android的构建系统会生成一个NOTICES.html.gz文件，在手机或平板电脑上，默认情况下该文件包含在“合法”选项卡中。该文件是由一个脚本生成，该脚本会查找指示许可证状态的相关文件，称为“NOTICE”。

For some tools and programs in Android, you may find missing license identifiers or have used the wrong license text (in case of the Linux kernel). These omissions were fixed in the most recent versions of Android (Android 6, possibly later versions of 5), but many older versions (including several versions of Android 5) do not have these fixes. Chipset manufacturers and ODMs typically have not applied the existing fixes because they were not informed by Google. The omission of these texts has been raised in enforcement cases.

对于Android中的一些工具和程序，您可能会发现缺少许可证标识符或使用了错误的许可文件（以Linux内核为例）。在最新版本的Android（Android6，可能是5之后的更高版本）中，这些遗漏已经得到修复，但许多旧版本（包括Android 5的多个版本）都还没有修复。芯片组制造商和ODM通常没有使用现有的修复程序，因为Google没有通知他们。在执行案件中，这些文本的遗漏已经被提出了。

The most common omissions and errors are with:

最常见的遗漏和错误是：

-   iproute2 --- missing license reference in the NOTICES file
-   iproute2 --- 在NOTICES文件中缺少许可证的引用

-   iptables --- missing license reference in the NOTICES file
-   iptables --- 在NOTICES文件中缺少许可证的引用

-   Linux kernel --- sometimes wrong version of the license in the NOTICES file (Linux kernel 2.6-specific)
-   Linux内核 --- 在NOTICES文件中有时会出现许可证版本错误（尤其是Linux内核2.6）

Fixing these issues is not hard at all, and patches are readily available, as described below.

修复这些问题一点都不难，修补程序也很容易获得，如下所述。

###### *iptables*

The notices and license files for iptables are missing in older versions of Android. Google fixed the bug in the following Git commit:

旧版本的Android系统中缺少iptables的通知和许可文件。Google修复了以下Git提交中的错误：

**[https://android.googlesource.com/platform/external/](https://android.googlesource.com/platform/external/iptables/%2B/b6da12d1a9020e2819f3c449244801a285659f)
[iptables/+/b6da12d1a9020e2819f3c449244801a285659f81](https://android.googlesource.com/platform/external/iptables/%2B/b6da12d1a9020e2819f3c449244801a285659f)**

###### *iproute2*

The notices and license files for iproute2 are missing in older versions of Android. Google fixed the bug in the following Git commit:

旧版本的Android系统中缺少iproute2的通知和许可文件。Google修复了以下Git提交中的错误：

**[https://android.googlesource.com/platform/external/](https://android.googlesource.com/platform/external/iproute2/%2B/5aa4845c8ef3ea0371955a2ba5f7baf7ed4e2d)
[iproute2/+/5aa4845c8ef3ea0371955a2ba5f7baf7ed4e2df4](https://android.googlesource.com/platform/external/iproute2/%2B/5aa4845c8ef3ea0371955a2ba5f7baf7ed4e2d)**

###### *Linux kernel*

The Linux kernel license file is sometimes wrong, because Google used the license text of a prebuilt Linux kernel (2.6.x), which has a slightly different license text than later versions. This was not a problem for Android versions using the 2.6.x kernel, but when the Linux kernel moved to 3.x and later 4.x, the license text was not
entirely correct. Google fixed this in late 2015:

Linux内核许可文件有时是错误的，因为Google使用了预构建Linux内核(2.6.x)的许可文本，其许可文本与更高版本的许可文件略有不同。这对于使用2.6.x内核的Android版本来说不是问题，但是当Linux内核迁移到3.x和更高的4.x版本时，许可文本并不完全正确。谷歌在2015年底修复了这个问题：

**[https://android.googlesource.com/platform/build/+/](https://android.googlesource.com/platform/build/%2B/b463fcde80f5615b3fe6891b8b78c010ec8cd37b)
[b463fcde80f5615b3fe6891b8b78c010ec8cd37b](https://android.googlesource.com/platform/build/%2B/b463fcde80f5615b3fe6891b8b78c010ec8cd37b)**

## Pitfall #3: "Out of tree" Linux Kernel Modules
## 陷阱#3：“外部的”Linux内核模块

Many vendors ship Linux kernel modules that add functionality that is not provided by the standard Linux kernel, or that is not yet present in the version shipped for the device, such as support for certain hardware, firewalling modules, new security features, etc. Linux kernel modules for the 2.6 and later releases have the ".ko"
extension. Kernel modules for the 2.4 and older kernel often have the extension ".o" (but that could also be used for regular object files).

许多供应商发布的Linux内核模块添加了标准的Linux内核未提供的功能，或者设备所提供的版本中尚不存在的功能，例如对某些硬件的支持、防火墙模块、新的安全功能等。Linux2.6及更高版本的内核模块通常具有“.ko”扩展名。2.4和更早版本的内核模块通常具有“.o”扩展名（但也可用于常规目标文件）。

For these so-called "out of tree" kernel modules, it is important to find out which license they are under and if there is complete and corresponding source code.

对于这些所谓的“外部的”内核模块，重要的是要弄清楚它们使用的哪个许可证，以及是否有完整的对应源代码。

Linux kernel modules can contain several fields that detail things such as the author and a description, but also a license field. An example from Linux kernel 4.5. (file "drivers/clk/clk-pwm.c") looks like this:

Linux内核模块可以包含多个详细的信息字段，比如作者和文件描述等，还有一个许可证字段。以Linux内核4.5为例，其（文件“drivers/clk/clk-pwm.c”）格式如下：

MODULE_AUTHOR("Philipp Zabel

[\<p.zabel@pengutronix.de\");](mailto:p.zabel@pengutronix.de)

MODULE_DESCRIPTION("PWM clock driver"); 

MODULE_LICENSE("GPL");

These fields are then included in the kernel module binary when it is built. They can later be extracted from the binary either by using the "modinfo" tool (preferred) or manually (as recent versions of "modinfo" no longer support the format for Linux kernel 2.4 or older). The important fields to look at are the author field and the
license field. The author field usually indicates the copyright holders of the specific code being reviewed. The license field could indicate the possible license of a file. This field is quite important, as certain pieces of functionality in the Linux kernel can only be used by modules that have explicitly declared that they are
GPL-licensed.

在构建内核模块二进制文件时，这些信息将包含在其中。之后可以使用“modinfo”工具（首选）或手动从二进制文件中提取它们（因为“modinfo”的最新版本不再支持Linux内核2.4或更高级的版本）。主要查看作者字段和许可证字段。作者字段通常表示审查当前代码的版权所有者。许可证字段可以指示文件的可能许可证。这个字段非常重要，因为Linux内核中的某些功能只能由明确声明为GPL许可的模块使用。

It also happens that kernel modules are distributed in a firmware or source code archive, but they are not used, because they are never loaded by the operating system, either because there are no programs to load them, or because the operating system does not allow it (it may be a different version or even a completely different
architecture). Finding out if a module is used is outside of the scope of this book.

还有一种情况是，内核模块分布在固件或源代码存档文件中，但未被使用过，因为操作系统从未加载过它们，要么是因为没有程序需要加载它们，要么是因为操作系统不允许（它可能是不同的版本，甚至是完全不同的体系结构）。确定一个模块是否被使用已经超出了本书的范围。

#### Extracting License and Author Fields from a Kernel Module
#### 从内核模块中提取许可证及作者信息

The license field can be extracted from a Linux kernel module using the modinfo tool:

使用以下的modinfo工具，可以从Linux内核模块中提取许可证字段：

\$ modinfo -l /path/to/kernel/module

Similarly, the author field can be extracted using:

类似地，可以通过以下方式提取作者字段：

\$ modinfo -a /path/to/kernel/module

Note: Recent versions of the modinfo program no longer have support for kernel modules for Linux kernel 2.4.X and earlier (using the ".o" extension). For those modules, you can use the "strings" command instead:

注意：最新版本的modinfo程序不再支持Linux内核2.4.X及更早版本的内核模块（使用“.o”扩展名）。对于这些模块，可以改用“strings”命令：

\$ strings /path/to/kernel/module \| grep -i license

#### Extracting Version and Architecture Fields from a Kernel Module
#### 从内核模块中提取版本及体系结构信息

Similarly to the license field, the version and architecture information can easily be retrieved from a Linux kernel module:

与许可证字段类似，可以从Linux内核模块轻松地提取版本和体系结构信息：

\$ modinfo /path/to/kernel/module \| grep \^vermagic

For 2.4.X and earlier, the version can be extracted as follows (because the modinfo tool on recent Linux distributions no longer can process modules for 2.4 or earlier):

对于2.4.X及更早的版本，可以按如下的方式提取版本信息（因为最近Linux发行版上的modinfo工具不再能够处理2.4或更早版本的模块）：

\$ strings /path/to/kernel/module \| grep kernel\_ version

The architecture can be retrieved using different means, such as the "file" command:

体系结构信息可以用不同的方法提取出来，比如“file”命令：

\$ file /path/to/kernel/module

## Pitfall #4: Rescue Mode/Install Mode Systems

Quite a few embedded Linux devices have a special mode that is used
only for system recovery (rescue mode) or when installing a new
firmware. This is done by booting a different Linux kernel from a
different partition on the flash memory. These rescue partitions are
often not updated when a new firmware is released and are simply
forgotten. However, for compliance, it is very important to have the
complete and corresponding source code for all of the different Linux
systems that are used on a device or while updating a firmware.

These rescue partitions tend to have different contents than other
partitions. It is very common to see that both the rescue partition
and the normal one have a copy of BusyBox, but with a different size
and set of tools integrated. This means that they were built with
different configurations. It is also not uncommon to see that a
different Linux kernel (older version, known to work) has been used,
but that the source code releases have the source code only for the
Linux kernel that is booted in normal operation. There have also been
instances where the C library was different (uClibc in the rescue
partition, glibc in the normal partition, and so on).

It also happens that a separate version of Linux is booted only to
perform the installation of a new firmware, and that version is
embedded in the firmware update itself and is not on the device. Or,
it could be that there are three different instances of Linux involved
in one single firmware update: a temporary Linux booted when
performing the update, a different version when writing a rescue
partition, as well as a third version for the regular partition. It is
important to look at everything that is installed or used at
installation time: The device and the firmware update are both
important.

## Pitfall #5: Bootloader

One overlooked component in compliance engineering is the bootloader.
A few commonly used bootloaders on embedded Linux systems (e.g.,
U-Boot and Redboot) are GPL-licensed. The reason they are overlooked
is because they come preflashed on the boards or chips, and ODMs
frequently do not touch this component at all. Many times the
bootloader is also not included in a firmware update, but the firmware
update overwrites only parts of the flash chip in a device and leaves
the bootloader alone. However, if the bootloader is GPL- licensed,
source code for the bootloader should be delivered as well.

If possible, perform your analysis on the firmware update as shipped
to customers (see "Pitfall #4") as well as on a dump of the flash
contents of the actual device, unless the firmware update is actually
the same as the flash dump.

If the bootloader is not included, it might be necessary to extract
the contents of the bootloader from the device. This is outside of the
scope of this book.

## Pitfall #6: Missing Build System

There are build systems that separate the sources of packages and the
description of how to build them. Some build systems have a directory
called "download" or "dl" that contains the sources, while the
Makefiles, configurations, and patches are in a separate directory.
Some companies will publish the contents of the directory only with
the sources but not the build system.

This is wrong for a few reasons:

1.  Any patches that might have been applied are now not included,
    meaning that the source code is incomplete.

2.  []{#_bookmark14 .anchor}Makefiles and other build scripts often
    contain configuration options (environment variables, compiler
    options, etc.) that influence how a package is built. Without this
    information, the binary cannot be rebuilt successfully, or at least
    not (near-)identically.

## Pitfall #7: Incorrect or Missing BusyBox Configuration Files

An often-encountered problem is that BusyBox cannot be rebuilt in such
a way that it corresponds to the binary or binaries in a firmware. The
BusyBox program is very modular; functionality can be added or removed
by editing a configuration file (usually using a special configuration
program). This configuration file is read during build time and
determines which functionalities (called "applets") will be included
in the BusyBox binary. The configuration file is therefore a very
necessary part of the "complete and corresponding source code," and a
missing or incorrect configuration file for BusyBox has been enforced
many times.

#### Missing BusyBox configuration file

Source code release archives often contain only the source code for
BusyBox, but not the configuration, because the build system is not
included (see Pitfall #6).

An easy check for this is to look for a file called ".config" in the
top-level source code file of the BusyBox source code tree. If it
cannot be found, it might be in a separate directory in the build
system, if present.

#### Incorrect BusyBox configuration file

Another problem encountered at times is that the BusyBox

[]{#_bookmark15 .anchor}configuration file or files are incorrect: The
original binary and the rebuilt binary have different sets of applets.
In many of these cases, the chipset manufacturer or ODM cannot find or
recreate the correct configuration file.

It is possible (with tools contained in the Binary Analysis Tool) to
re-create a BusyBox configuration file that could be used as the basis
of re-creating the real configuration file. However, this solution
should be used only as a last resort.

#### Multiple different BusyBox binaries, one configuration file

Quite often there are multiple BusyBox binaries included in a
firmware, each with a different configuration. A common example is a
rescue system (see Pitfall #4) that contains a minimal version of
BusyBox, with the full system containing a BusyBox instance with much
more functionality. The source code archive should include the
configurations for all Busybox instances that are in use on the
device, but frequently, the configuration for only one of the
instances of BusyBox is present.

## Pitfall #8: Incorrect or Missing Linux Kernel Configuration Files

Very similarly to Pitfall #7, the configuration file for the Linux
kernel is often missing or incorrect.

#### Finding which Linux kernel configuration was used

Finding out what configuration was used to build a Linux kernel binary
is not always trivial, and sometimes a rebuild and comparison (as
described earlier in this book) will be necessary. Sometimes the
kernel configuration will be included in the Linux kernel binary

as a bzip2 compressed file. This happens if the "CONFIG\_ IKCONFIG"
option was enabled during the kernel build. In that case, it is easy
to find the kernel configuration that was actually used (for example,
by unpacking the binary with the Binary Analysis Tool and then looking
for the configuration). If the configuration was not stored in the
Linux kernel image, then your only option to verify whether a kernel
configuration is 100% correct is a rebuild and compare.

#### Missing Linux kernel configuration file

Source code release archives often contain only the source code for
the Linux kernel, but not the configuration. Depending on the setup,
the Linux kernel configuration could be in various locations. One
common location is a file ".config" in the root of the Linux kernel
source tree (generated by the Linux kernel configuration commands like
"make config" or "make menuconfig"). Another location is in the "arch"
subdirectory. By default, the Linux kernel source code tree contains
many configuration files, and vendors tend to put the configurations
there. For example, "arch/arm/ configs/bcm2835_defconfig" contains the
configuration for a particular Broadcom board. Which configuration
file to use is set by the build scripts. A third option is that the
configuration file is kept outside of the Linux kernel archive, with
the build scripts, and is first copied to the Linux kernel source code
tree during the build. If the build system is missing (see Pitfall #6)
and the configuration file is not included in the Linux kernel
archive, then the Linux kernel source code will not be complete and
corresponding.

#### Multiple Linux kernel binaries, one configuration file

Quite often there are multiple Linux kernel binaries included in a
firmware, each with a different configuration. A common example is a
rescue system (see Pitfall #4) which contains a minimal version of the
Linux kernel, with the full system containing a Linux kernel

[]{#_bookmark16 .anchor}instance with much more functionality. The
source code archive, however, may have the configuration for only one
of the two versions (or three, or even more).

#### Incorrect Linux kernel configuration file

It also happens that the Linux kernel configuration file may simply be
not correct and that the appropriate Linux kernel binary cannot be
compiled because functionality has been added or removed in the
configuration.

## Pitfall #9: Not Including the Version Number in Firmware and Source Code Archive Filenames

One very common mistake is that firmwares and corresponding source
code archives often do not have the version name (and the device name)
in the filename, but use a generic name, such as "GPL.zip," for
various devices and versions of source code. This makes it very easy
to make mistakes and deliver the wrong files, which might lead to the
impression that you are out of compliance.

The solution is to use, or demand that suppliers use, a naming
convention that would include:

-   Device name/model number (or multiple, if the files are identical)

-   Firmware revision number

-   Revision level

For example: A device called AB-123 with firmware 1.2.3.4 would have a
firmware filename "FW_AB-123_1.2.3.4.bin" and a source code archive
filename "GPL_AB-123_1.2.3.4-0.bin."

Using naming conventions like these will make it a lot easier to
locate the right files, avoid making mistakes, and spot errors on
download sites.

